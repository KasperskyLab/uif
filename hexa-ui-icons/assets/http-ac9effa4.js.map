{"version":3,"file":"http-ac9effa4.js","sources":["../../../node_modules/refractor/lang/http.js"],"sourcesContent":["'use strict'\n\nmodule.exports = http\nhttp.displayName = 'http'\nhttp.aliases = []\nfunction http(Prism) {\n  ;(function(Prism) {\n    Prism.languages.http = {\n      'request-line': {\n        pattern: /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\s(?:https?:\\/\\/|\\/)\\S+\\sHTTP\\/[0-9.]+/m,\n        inside: {\n          // HTTP Verb\n          property: /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\b/,\n          // Path or query argument\n          'attr-name': /:\\w+/\n        }\n      },\n      'response-status': {\n        pattern: /^HTTP\\/1.[01] \\d+.*/m,\n        inside: {\n          // Status, e.g. 200 OK\n          property: {\n            pattern: /(^HTTP\\/1.[01] )\\d+.*/i,\n            lookbehind: true\n          }\n        }\n      },\n      // HTTP header name\n      'header-name': {\n        pattern: /^[\\w-]+:(?=.)/m,\n        alias: 'keyword'\n      }\n    } // Create a mapping of Content-Type headers to language definitions\n    var langs = Prism.languages\n    var httpLanguages = {\n      'application/javascript': langs.javascript,\n      'application/json': langs.json || langs.javascript,\n      'application/xml': langs.xml,\n      'text/xml': langs.xml,\n      'text/html': langs.html,\n      'text/css': langs.css\n    } // Declare which types can also be suffixes\n    var suffixTypes = {\n      'application/json': true,\n      'application/xml': true\n    }\n    /**\n     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\n     *\n     * @param {string} contentType\n     * @returns {string}\n     */\n    function getSuffixPattern(contentType) {\n      var suffix = contentType.replace(/^[a-z]+\\//, '')\n      var suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])'\n      return '(?:' + contentType + '|' + suffixPattern + ')'\n    } // Insert each content type parser that has its associated language\n    // currently loaded.\n    var options\n    for (var contentType in httpLanguages) {\n      if (httpLanguages[contentType]) {\n        options = options || {}\n        var pattern = suffixTypes[contentType]\n          ? getSuffixPattern(contentType)\n          : contentType\n        options[contentType] = {\n          pattern: RegExp(\n            '(content-type:\\\\s*' +\n              pattern +\n              '[\\\\s\\\\S]*?)(?:\\\\r?\\\\n|\\\\r){2}[\\\\s\\\\S]*',\n            'i'\n          ),\n          lookbehind: true,\n          inside: {\n            rest: httpLanguages[contentType]\n          }\n        }\n      }\n    }\n    if (options) {\n      Prism.languages.insertBefore('http', 'header-name', options)\n    }\n  })(Prism)\n}\n"],"names":["http_1","http","Prism","langs","httpLanguages","suffixTypes","getSuffixPattern","contentType","suffix","suffixPattern","options","pattern"],"mappings":"gbAEAA,EAAiBC,EACjBA,EAAK,YAAc,OACnBA,EAAK,QAAU,CAAE,EACjB,SAASA,EAAKC,EAAO,EACjB,SAASA,EAAO,CAChBA,EAAM,UAAU,KAAO,CACrB,eAAgB,CACd,QAAS,8FACT,OAAQ,CAEN,SAAU,yDAEV,YAAa,MACd,CACF,EACD,kBAAmB,CACjB,QAAS,uBACT,OAAQ,CAEN,SAAU,CACR,QAAS,yBACT,WAAY,EACb,CACF,CACF,EAED,cAAe,CACb,QAAS,iBACT,MAAO,SACR,CACF,EACD,IAAIC,EAAQD,EAAM,UACdE,EAAgB,CAClB,yBAA0BD,EAAM,WAChC,mBAAoBA,EAAM,MAAQA,EAAM,WACxC,kBAAmBA,EAAM,IACzB,WAAYA,EAAM,IAClB,YAAaA,EAAM,KACnB,WAAYA,EAAM,GACnB,EACGE,EAAc,CAChB,mBAAoB,GACpB,kBAAmB,EACpB,EAOD,SAASC,EAAiBC,EAAa,CACrC,IAAIC,EAASD,EAAY,QAAQ,YAAa,EAAE,EAC5CE,EAAgB,wBAA0BD,EAAS,eACvD,MAAO,MAAQD,EAAc,IAAME,EAAgB,GACpD,CAED,IAAIC,EACJ,QAASH,KAAeH,EACtB,GAAIA,EAAcG,CAAW,EAAG,CAC9BG,EAAUA,GAAW,CAAE,EACvB,IAAIC,EAAUN,EAAYE,CAAW,EACjCD,EAAiBC,CAAW,EAC5BA,EACJG,EAAQH,CAAW,EAAI,CACrB,QAAS,OACP,qBACEI,EACA,yCACF,GACD,EACD,WAAY,GACZ,OAAQ,CACN,KAAMP,EAAcG,CAAW,CAChC,CACF,CACF,CAECG,GACFR,EAAM,UAAU,aAAa,OAAQ,cAAeQ,CAAO,CAE9D,GAAER,CAAK,CACV","x_google_ignoreList":[0]}