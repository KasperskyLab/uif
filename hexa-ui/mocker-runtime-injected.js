var __defProp=Object.defineProperty,__defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:!0,configurable:!0,writable:!0,value}):obj[key]=value,__publicField=(obj,key,value)=>__defNormalProp(obj,"symbol"!=typeof key?key+"":key,value),MockerRegistry=class{constructor(){__publicField(this,"registryByUrl",new Map),__publicField(this,"registryById",new Map)}clear(){this.registryByUrl.clear(),this.registryById.clear()}keys(){return this.registryByUrl.keys()}add(mock){this.registryByUrl.set(mock.url,mock),this.registryById.set(mock.id,mock)}register(typeOrEvent,raw,id,url,factoryOrRedirect){const type="object"==typeof typeOrEvent?typeOrEvent.type:typeOrEvent;if("object"==typeof typeOrEvent){const event=typeOrEvent;if(event instanceof AutomockedModule||event instanceof AutospiedModule||event instanceof ManualMockedModule||event instanceof RedirectedModule)throw new TypeError(`[vitest] Cannot register a mock that is already defined. Expected a JSON representation from \`MockedModule.toJSON\`, instead got "${event.type}". Use "registry.add()" to update a mock instead.`);if("automock"===event.type){const module=AutomockedModule.fromJSON(event);return this.add(module),module}if("autospy"===event.type){const module=AutospiedModule.fromJSON(event);return this.add(module),module}if("redirect"===event.type){const module=RedirectedModule.fromJSON(event);return this.add(module),module}throw"manual"===event.type?new Error("Cannot set serialized manual mock. Define a factory function manually with `ManualMockedModule.fromJSON()`."):new Error(`Unknown mock type: ${event.type}`)}if("string"!=typeof raw)throw new TypeError("[vitest] Mocks require a raw string.");if("string"!=typeof url)throw new TypeError("[vitest] Mocks require a url string.");if("string"!=typeof id)throw new TypeError("[vitest] Mocks require an id string.");if("manual"===type){if("function"!=typeof factoryOrRedirect)throw new TypeError("[vitest] Manual mocks require a factory function.");const mock=new ManualMockedModule(raw,id,url,factoryOrRedirect);return this.add(mock),mock}if("automock"===type||"autospy"===type){const mock="automock"===type?new AutomockedModule(raw,id,url):new AutospiedModule(raw,id,url);return this.add(mock),mock}if("redirect"===type){if("string"!=typeof factoryOrRedirect)throw new TypeError("[vitest] Redirect mocks require a redirect string.");const mock=new RedirectedModule(raw,id,url,factoryOrRedirect);return this.add(mock),mock}throw new Error(`[vitest] Unknown mock type: ${type}`)}delete(id){this.registryByUrl.delete(id)}deleteById(id){this.registryById.delete(id)}get(id){return this.registryByUrl.get(id)}getById(id){return this.registryById.get(id)}has(id){return this.registryByUrl.has(id)}},AutomockedModule=class{constructor(raw,id,url){__publicField(this,"type","automock"),this.raw=raw,this.id=id,this.url=url}static fromJSON(data){return new AutospiedModule(data.raw,data.id,data.url)}toJSON(){return{type:this.type,url:this.url,raw:this.raw,id:this.id}}},AutospiedModule=class _AutospiedModule{constructor(raw,id,url){__publicField(this,"type","autospy"),this.raw=raw,this.id=id,this.url=url}static fromJSON(data){return new _AutospiedModule(data.raw,data.id,data.url)}toJSON(){return{type:this.type,url:this.url,id:this.id,raw:this.raw}}},RedirectedModule=class _RedirectedModule{constructor(raw,id,url,redirect){__publicField(this,"type","redirect"),this.raw=raw,this.id=id,this.url=url,this.redirect=redirect}static fromJSON(data){return new _RedirectedModule(data.raw,data.id,data.url,data.redirect)}toJSON(){return{type:this.type,url:this.url,raw:this.raw,id:this.id,redirect:this.redirect}}},ManualMockedModule=class _ManualMockedModule{constructor(raw,id,url,factory){__publicField(this,"cache"),__publicField(this,"type","manual"),this.raw=raw,this.id=id,this.url=url,this.factory=factory}async resolve(){if(this.cache)return this.cache;let exports$1;try{exports$1=await this.factory()}catch(err){const vitestError=new Error('[vitest] There was an error when mocking a module. If you are using "vi.mock" factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock');throw vitestError.cause=err,vitestError}if(null===exports$1||"object"!=typeof exports$1||Array.isArray(exports$1))throw new TypeError(`[vitest] vi.mock("${this.raw}", factory?: () => unknown) is not returning an object. Did you mean to return an object with a "default" key?`);return this.cache=exports$1}static fromJSON(data,factory){return new _ManualMockedModule(data.raw,data.id,data.url,factory)}toJSON(){return{type:this.type,url:this.url,id:this.id,raw:this.raw}}};function mockObject(options,object,mockExports={}){const finalizers=new Array,refs=new RefTracker,define=(container,key,value)=>{try{return container[key]=value,!0}catch{return!1}},createMock=currentValue=>{if(!options.createMockInstance)throw new Error("[@vitest/mocker] `createMockInstance` is not defined. This is a Vitest error. Please open a new issue with reproduction.");const createMockInstance=options.createMockInstance,prototypeMembers=currentValue.prototype?collectFunctionProperties(currentValue.prototype):[];return createMockInstance({name:currentValue.name,prototypeMembers,originalImplementation:"autospy"===options.type?currentValue:void 0,keepMembersImplementation:"autospy"===options.type})},mockPropertiesOf=(container,newContainer)=>{const isModule="Module"===getType(container)||!!container.__esModule;for(const{key:property,descriptor}of getAllMockableProperties(container,isModule,options.globalConstructors)){if(!isModule&&descriptor.get){try{"autospy"===options.type?Object.defineProperty(newContainer,property,descriptor):Object.defineProperty(newContainer,property,{configurable:descriptor.configurable,enumerable:descriptor.enumerable,get:()=>{},set:descriptor.set?()=>{}:void 0})}catch{}continue}if(isReadonlyProp(container[property],property))continue;const value=container[property],refId=refs.getId(value);if(void 0!==refId){finalizers.push((()=>define(newContainer,property,refs.getMockedValue(refId))));continue}const type=getType(value);if(Array.isArray(value)){if("automock"===options.type)define(newContainer,property,[]);else{const array=value.map((value2=>{if(value2&&"object"==typeof value2){const newObject={};return mockPropertiesOf(value2,newObject),newObject}return"function"==typeof value2?createMock(value2):value2}));define(newContainer,property,array)}continue}const isFunction=type.includes("Function")&&"function"==typeof value;if(isFunction&&!value._isMockFunction||"Object"===type||"Module"===type){if(define(newContainer,property,isFunction||"autospy"===options.type?value:{})){if(isFunction){const mock=createMock(newContainer[property]);newContainer[property]=mock}refs.track(value,newContainer[property]),mockPropertiesOf(value,newContainer[property])}}else define(newContainer,property,value)}},mockedObject=mockExports;mockPropertiesOf(object,mockedObject);for(const finalizer of finalizers)finalizer();return mockedObject}var RefTracker=class{constructor(){__publicField(this,"idMap",new Map),__publicField(this,"mockedValueMap",new Map)}getId(value){return this.idMap.get(value)}getMockedValue(id){return this.mockedValueMap.get(id)}track(originalValue,mockedValue){const newId=this.idMap.size;return this.idMap.set(originalValue,newId),this.mockedValueMap.set(newId,mockedValue),newId}};function getType(value){return Object.prototype.toString.apply(value).slice(8,-1)}function isReadonlyProp(object,prop){if("arguments"===prop||"caller"===prop||"callee"===prop||"name"===prop||"length"===prop){const typeName=getType(object);return"Function"===typeName||"AsyncFunction"===typeName||"GeneratorFunction"===typeName||"AsyncGeneratorFunction"===typeName}return("source"===prop||"global"===prop||"ignoreCase"===prop||"multiline"===prop)&&"RegExp"===getType(object)}function getAllMockableProperties(obj,isModule,constructors){const{Map:Map2,Object:Object2,Function:Function2,RegExp:RegExp2,Array:Array2}=constructors,allProps=new Map2;let curr=obj;do{if(curr===Object2.prototype||curr===Function2.prototype||curr===RegExp2.prototype)break;collectOwnProperties(curr,(key=>{const descriptor=Object2.getOwnPropertyDescriptor(curr,key);descriptor&&allProps.set(key,{key,descriptor})}))}while(curr=Object2.getPrototypeOf(curr));if(isModule&&!allProps.has("default")&&"default"in obj){const descriptor=Object2.getOwnPropertyDescriptor(obj,"default");descriptor&&allProps.set("default",{key:"default",descriptor})}return Array2.from(allProps.values())}function collectOwnProperties(obj,collector){const collect="function"==typeof collector?collector:key=>collector.add(key);Object.getOwnPropertyNames(obj).forEach(collect),Object.getOwnPropertySymbols(obj).forEach(collect)}function collectFunctionProperties(prototype){const properties=new Set;return collectOwnProperties(prototype,(prop=>{const descriptor=Object.getOwnPropertyDescriptor(prototype,prop);if(!descriptor||descriptor.get)return;getType(descriptor.value).includes("Function")&&!isReadonlyProp(descriptor.value,prop)&&properties.add(prop)})),Array.from(properties)}var _DRIVE_LETTER_START_RE=/^[A-Za-z]:\//;function normalizeWindowsPath(input=""){return input?input.replace(/\\/g,"/").replace(_DRIVE_LETTER_START_RE,(r=>r.toUpperCase())):input}var _UNC_REGEX=/^[/\\]{2}/,_IS_ABSOLUTE_RE=/^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/,_DRIVE_LETTER_RE=/^[A-Za-z]:$/,_EXTNAME_RE=/.(\.[^./]+|\.)$/,normalize=function(path){if(0===path.length)return".";const isUNCPath=(path=normalizeWindowsPath(path)).match(_UNC_REGEX),isPathAbsolute=isAbsolute(path),trailingSeparator="/"===path[path.length-1];return 0===(path=normalizeString(path,!isPathAbsolute)).length?isPathAbsolute?"/":trailingSeparator?"./":".":(trailingSeparator&&(path+="/"),_DRIVE_LETTER_RE.test(path)&&(path+="/"),isUNCPath?isPathAbsolute?`//${path}`:`//./${path}`:isPathAbsolute&&!isAbsolute(path)?`/${path}`:path)},join=function(...segments){let path="";for(const seg of segments)if(seg)if(path.length>0){const pathTrailing="/"===path[path.length-1],segLeading="/"===seg[0];path+=pathTrailing&&segLeading?seg.slice(1):pathTrailing||segLeading?seg:`/${seg}`}else path+=seg;return normalize(path)};function normalizeString(path,allowAboveRoot){let res="",lastSegmentLength=0,lastSlash=-1,dots=0,char=null;for(let index=0;index<=path.length;++index){if(index<path.length)char=path[index];else{if("/"===char)break;char="/"}if("/"===char){if(lastSlash===index-1||1===dots);else if(2===dots){if(res.length<2||2!==lastSegmentLength||"."!==res[res.length-1]||"."!==res[res.length-2]){if(res.length>2){const lastSlashIndex=res.lastIndexOf("/");-1===lastSlashIndex?(res="",lastSegmentLength=0):(res=res.slice(0,lastSlashIndex),lastSegmentLength=res.length-1-res.lastIndexOf("/")),lastSlash=index,dots=0;continue}if(res.length>0){res="",lastSegmentLength=0,lastSlash=index,dots=0;continue}}allowAboveRoot&&(res+=res.length>0?"/..":"..",lastSegmentLength=2)}else res.length>0?res+=`/${path.slice(lastSlash+1,index)}`:res=path.slice(lastSlash+1,index),lastSegmentLength=index-lastSlash-1;lastSlash=index,dots=0}else"."===char&&-1!==dots?++dots:dots=-1}return res}var isAbsolute=function(p){return _IS_ABSOLUTE_RE.test(p)},extname=function(p){if(".."===p)return"";const match=_EXTNAME_RE.exec(normalizeWindowsPath(p));return match&&match[1]||""};function createSimpleStackTrace(options){const{message="$$stack trace error",stackTraceLimit=1}=options||{},limit=Error.stackTraceLimit,prepareStackTrace=Error.prepareStackTrace;Error.stackTraceLimit=stackTraceLimit,Error.prepareStackTrace=e=>e.stack;const stackTrace=new Error(message).stack||"";return Error.prepareStackTrace=prepareStackTrace,Error.stackTraceLimit=limit,stackTrace}var _DRIVE_LETTER_START_RE2=/^[A-Za-z]:\//;function normalizeWindowsPath2(input=""){return input?input.replace(/\\/g,"/").replace(_DRIVE_LETTER_START_RE2,(r=>r.toUpperCase())):input}var _IS_ABSOLUTE_RE2=/^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;function cwd(){return"undefined"!=typeof process&&"function"==typeof process.cwd?process.cwd().replace(/\\/g,"/"):"/"}var resolve=function(...arguments_){let resolvedPath="",resolvedAbsolute=!1;for(let index=(arguments_=arguments_.map((argument=>normalizeWindowsPath2(argument)))).length-1;index>=-1&&!resolvedAbsolute;index--){const path=index>=0?arguments_[index]:cwd();path&&0!==path.length&&(resolvedPath=`${path}/${resolvedPath}`,resolvedAbsolute=isAbsolute2(path))}return resolvedPath=normalizeString2(resolvedPath,!resolvedAbsolute),resolvedAbsolute&&!isAbsolute2(resolvedPath)?`/${resolvedPath}`:resolvedPath.length>0?resolvedPath:"."};function normalizeString2(path,allowAboveRoot){let res="",lastSegmentLength=0,lastSlash=-1,dots=0,char=null;for(let index=0;index<=path.length;++index){if(index<path.length)char=path[index];else{if("/"===char)break;char="/"}if("/"===char){if(lastSlash===index-1||1===dots);else if(2===dots){if(res.length<2||2!==lastSegmentLength||"."!==res[res.length-1]||"."!==res[res.length-2]){if(res.length>2){const lastSlashIndex=res.lastIndexOf("/");-1===lastSlashIndex?(res="",lastSegmentLength=0):(res=res.slice(0,lastSlashIndex),lastSegmentLength=res.length-1-res.lastIndexOf("/")),lastSlash=index,dots=0;continue}if(res.length>0){res="",lastSegmentLength=0,lastSlash=index,dots=0;continue}}allowAboveRoot&&(res+=res.length>0?"/..":"..",lastSegmentLength=2)}else res.length>0?res+=`/${path.slice(lastSlash+1,index)}`:res=path.slice(lastSlash+1,index),lastSegmentLength=index-lastSlash-1;lastSlash=index,dots=0}else"."===char&&-1!==dots?++dots:dots=-1}return res}var isAbsolute2=function(p){return _IS_ABSOLUTE_RE2.test(p)},chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",intToChar=new Uint8Array(64),charToInt=new Uint8Array(128);for(let i=0;i<chars.length;i++){const c=chars.charCodeAt(i);intToChar[i]=c,charToInt[c]=i}var CHROME_IE_STACK_REGEXP=/^\s*at .*(?:\S:\d+|\(native\))/m,SAFARI_NATIVE_CODE_REGEXP=/^(?:eval@)?(?:\[native code\])?$/;function extractLocation(urlLike){if(!urlLike.includes(":"))return[urlLike];const parts=/(.+?)(?::(\d+))?(?::(\d+))?$/.exec(urlLike.replace(/^\(|\)$/g,""));if(!parts)return[urlLike];let url=parts[1];if(url.startsWith("async ")&&(url=url.slice(6)),url.startsWith("http:")||url.startsWith("https:")){const urlObj=new URL(url);urlObj.searchParams.delete("import"),urlObj.searchParams.delete("browserv"),url=urlObj.pathname+urlObj.hash+urlObj.search}if(url.startsWith("/@fs/")){const isWindows=/^\/@fs\/[a-zA-Z]:\//.test(url);url=url.slice(isWindows?5:4)}return[url,parts[2]||void 0,parts[3]||void 0]}function parseSingleFFOrSafariStack(raw){let line=raw.trim();if(SAFARI_NATIVE_CODE_REGEXP.test(line))return null;if(line.includes(" > eval")&&(line=line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),!line.includes("@"))return null;let functionName,atIndex=-1,locationPart="";for(let i=0;i<line.length;i++)if("@"===line[i]){const candidateLocation=line.slice(i+1);if(candidateLocation.includes(":")&&candidateLocation.length>=3){atIndex=i,locationPart=candidateLocation,functionName=i>0?line.slice(0,i):void 0;break}}if(-1===atIndex||!locationPart.includes(":")||locationPart.length<3)return null;const[url,lineNumber,columnNumber]=extractLocation(locationPart);return url&&lineNumber&&columnNumber?{file:url,method:functionName||"",line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)}:null}function parseSingleStack(raw){const line=raw.trim();return CHROME_IE_STACK_REGEXP.test(line)?parseSingleV8Stack(line):parseSingleFFOrSafariStack(line)}function parseSingleV8Stack(raw){let line=raw.trim();if(!CHROME_IE_STACK_REGEXP.test(line))return null;line.includes("(eval ")&&(line=line.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(,.*$)/g,""));let sanitizedLine=line.replace(/^\s+/,"").replace(/\(eval code/g,"(").replace(/^.*?\s+/,"");const location2=sanitizedLine.match(/ (\(.+\)$)/);sanitizedLine=location2?sanitizedLine.replace(location2[0],""):sanitizedLine;const[url,lineNumber,columnNumber]=extractLocation(location2?location2[1]:sanitizedLine);let method=location2&&sanitizedLine||"",file=url&&["eval","<anonymous>"].includes(url)?void 0:url;return file&&lineNumber&&columnNumber?(method.startsWith("async ")&&(method=method.slice(6)),file.startsWith("file://")&&(file=file.slice(7)),file=file.startsWith("node:")||file.startsWith("internal:")?file:resolve(file),method&&(method=method.replace(/__vite_ssr_import_\d+__\./g,"").replace(/(Object\.)?__vite_ssr_export_default__\s?/g,"")),{method,file,line:Number.parseInt(lineNumber),column:Number.parseInt(columnNumber)}):null}function createCompilerHints(options){const globalThisAccessor=(null==options?void 0:options.globalThisKey)||"__vitest_mocker__";function _mocker(){return void 0!==globalThis[globalThisAccessor]?globalThis[globalThisAccessor]:new Proxy({},{get(_,name){throw new Error(`Vitest mocker was not initialized in this environment. vi.${String(name)}() is forbidden.`)}})}return{hoisted(factory){if("function"!=typeof factory)throw new TypeError("vi.hoisted() expects a function, but received a "+typeof factory);return factory()},mock(path,factory){if("string"!=typeof path)throw new TypeError("vi.mock() expects a string path, but received a "+typeof path);const importer=getImporter("mock");_mocker().queueMock(path,importer,"function"==typeof factory?()=>factory((()=>_mocker().importActual(path,importer))):factory)},unmock(path){if("string"!=typeof path)throw new TypeError("vi.unmock() expects a string path, but received a "+typeof path);_mocker().queueUnmock(path,getImporter("unmock"))},doMock(path,factory){if("string"!=typeof path)throw new TypeError("vi.doMock() expects a string path, but received a "+typeof path);const importer=getImporter("doMock");_mocker().queueMock(path,importer,"function"==typeof factory?()=>factory((()=>_mocker().importActual(path,importer))):factory)},doUnmock(path){if("string"!=typeof path)throw new TypeError("vi.doUnmock() expects a string path, but received a "+typeof path);_mocker().queueUnmock(path,getImporter("doUnmock"))},importActual:async path=>_mocker().importActual(path,getImporter("importActual")),importMock:async path=>_mocker().importMock(path,getImporter("importMock"))}}function getImporter(name){const stackArray=createSimpleStackTrace({stackTraceLimit:5}).split("\n"),importerStackIndex=stackArray.findIndex((stack2=>stack2.includes(` at Object.${name}`)||stack2.includes(`${name}@`))),stack=parseSingleStack(stackArray[importerStackIndex+1]);return(null==stack?void 0:stack.file)||""}var hot=import.meta.hot||{on:warn,off:warn,send:warn};function warn(){console.warn("Vitest mocker cannot work if Vite didn't establish WS connection.")}var{now}=Date,ModuleMocker=class{constructor(interceptor,rpc2,createMockInstance,config){__publicField(this,"registry",new MockerRegistry),__publicField(this,"queue",new Set),__publicField(this,"mockedIds",new Set),this.interceptor=interceptor,this.rpc=rpc2,this.createMockInstance=createMockInstance,this.config=config}async prepare(){this.queue.size&&await Promise.all([...this.queue.values()])}async resolveFactoryModule(id){const mock=this.registry.get(id);if(!mock||"manual"!==mock.type)throw new Error(`Mock ${id} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);return await mock.resolve()}getFactoryModule(id){const mock=this.registry.get(id);if(!mock||"manual"!==mock.type)throw new Error(`Mock ${id} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);if(!mock.cache)throw new Error(`Mock ${id} wasn't resolved. This is probably a Vitest error. Please, open a new issue with reproduction.`);return mock.cache}async invalidate(){const ids=Array.from(this.mockedIds);ids.length&&(await this.rpc.invalidate(ids),await this.interceptor.invalidate(),this.registry.clear())}async importActual(id,importer){const resolved=await this.rpc.resolveId(id,importer);if(null==resolved)throw new Error(`[vitest] Cannot resolve "${id}" imported from "${importer}"`);const ext=extname(resolved.id),url=new URL(resolved.url,location.href),query=`_vitest_original&ext${ext}`,actualUrl=`${url.pathname}${url.search?`${url.search}&${query}`:`?${query}`}${url.hash}`;return this.wrapDynamicImport((()=>import(actualUrl))).then((mod=>{if(!resolved.optimized||void 0===mod.default)return mod;const m=mod.default;return(null==m?void 0:m.__esModule)?m:{..."object"==typeof m&&!Array.isArray(m)||"function"==typeof m?m:{},default:m}}))}async importMock(rawId,importer){await this.prepare();const{resolvedId,resolvedUrl,redirectUrl}=await this.rpc.resolveMock(rawId,importer,{mock:"auto"}),mockUrl=this.resolveMockPath(cleanVersion(resolvedUrl));let mock=this.registry.get(mockUrl);if(!mock)if(redirectUrl){const resolvedRedirect=new URL(this.resolveMockPath(cleanVersion(redirectUrl)),location.href).toString();mock=new RedirectedModule(rawId,resolvedId,mockUrl,resolvedRedirect)}else mock=new AutomockedModule(rawId,resolvedId,mockUrl);if("manual"===mock.type)return await mock.resolve();if("automock"===mock.type||"autospy"===mock.type){const url=new URL(`/@id/${resolvedId}`,location.href),query=url.search?`${url.search}&t=${now()}`:`?t=${now()}`,moduleObject=await import(`${url.pathname}${query}&mock=${mock.type}${url.hash}`);return this.mockObject(moduleObject,mock.type)}return import(mock.redirect)}mockObject(object,moduleType="automock"){return mockObject({globalConstructors:{Object,Function,Array,Map,RegExp},createMockInstance:this.createMockInstance,type:moduleType},object)}queueMock(rawId,importer,factoryOrOptions){const promise=this.rpc.resolveMock(rawId,importer,{mock:"function"==typeof factoryOrOptions?"factory":(null==factoryOrOptions?void 0:factoryOrOptions.spy)?"spy":"auto"}).then((async({redirectUrl,resolvedId,resolvedUrl,needsInterop,mockType})=>{const mockUrl=this.resolveMockPath(cleanVersion(resolvedUrl));this.mockedIds.add(resolvedId);const factory="function"==typeof factoryOrOptions?async()=>{const data=await factoryOrOptions();return needsInterop?{default:data}:data}:void 0,mockRedirect="string"==typeof redirectUrl?new URL(this.resolveMockPath(cleanVersion(redirectUrl)),location.href).toString():null;let module;module="manual"===mockType?this.registry.register("manual",rawId,resolvedId,mockUrl,factory):"autospy"===mockType?this.registry.register("autospy",rawId,resolvedId,mockUrl):"redirect"===mockType?this.registry.register("redirect",rawId,resolvedId,mockUrl,mockRedirect):this.registry.register("automock",rawId,resolvedId,mockUrl),await this.interceptor.register(module)})).finally((()=>{this.queue.delete(promise)}));this.queue.add(promise)}queueUnmock(id,importer){const promise=this.rpc.resolveId(id,importer).then((async resolved=>{if(!resolved)return;const mockUrl=this.resolveMockPath(cleanVersion(resolved.url));this.mockedIds.add(resolved.id),this.registry.delete(mockUrl),await this.interceptor.delete(mockUrl)})).finally((()=>{this.queue.delete(promise)}));this.queue.add(promise)}wrapDynamicImport(moduleFactory){if("function"==typeof moduleFactory){return new Promise(((resolve2,reject)=>{this.prepare().finally((()=>{moduleFactory().then(resolve2,reject)}))}))}return moduleFactory}resolveMockPath(path){const config=this.config,fsRoot=join("/@fs/",config.root);return path.startsWith(config.root)?path.slice(config.root.length):path.startsWith(fsRoot)?path.slice(fsRoot.length):path}},versionRegexp=/(\?|&)v=\w{8}/;function cleanVersion(url){return url.replace(versionRegexp,"")}var ModuleMockerInterceptor=class{constructor(){__publicField(this,"mocks",new MockerRegistry)}async register(module){this.mocks.add(module)}async delete(url){this.mocks.delete(url)}async invalidate(){this.mocks.clear()}},rpc=method=>{switch(method){case"resolveId":return Promise.resolve({id:"",url:"",optimized:!1});case"resolveMock":return Promise.resolve({mockType:"dummy",resolvedId:"",resolvedUrl:"",redirectUrl:"",needsInterop:!1});case"invalidate":return Promise.resolve()}},BuildModuleMocker=class extends ModuleMocker{queueMock(){}};function registerModuleMocker(interceptor){const mocker=new BuildModuleMocker(interceptor("__vitest_mocker__"),{resolveId:(id,importer)=>rpc("resolveId",{id,importer}),resolveMock:(id,importer,options)=>rpc("resolveMock",{id,importer,options}),invalidate:async ids=>rpc("invalidate",{ids})},((...args)=>globalThis.__STORYBOOK_MODULE_TEST__.spyOn(...args)),{root:""});return globalThis.__vitest_mocker__=mocker,createCompilerHints({globalThisKey:"__vitest_mocker__"})}globalThis.__STORYBOOK_MOCKER__=registerModuleMocker((()=>new ModuleMockerInterceptor));export{ModuleMockerInterceptor};